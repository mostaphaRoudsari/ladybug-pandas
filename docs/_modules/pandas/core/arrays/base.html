<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pandas.core.arrays.base &#8212; ladybug-pandas  documentation</title>
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html">
          ladybug-pandas</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ladybug_pandas.html">ladybug_pandas package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../ladybug_pandas.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../ladybug_pandas.accessors.html">ladybug_pandas.accessors package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../ladybug_pandas.accessors.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../../ladybug_pandas.accessors.ladybug.html">ladybug_pandas.accessors.ladybug module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../../ladybug_pandas.accessors.psychrometrics.html">ladybug_pandas.accessors.psychrometrics module</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../../ladybug_pandas.accessors.html#module-ladybug_pandas.accessors">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../ladybug_pandas.extension_types.html">ladybug_pandas.extension_types package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../ladybug_pandas.extension_types.html#submodules">Submodules</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../../../ladybug_pandas.extension_types.arraytype.html">ladybug_pandas.extension_types.arraytype module</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../../../ladybug_pandas.extension_types.dtype.html">ladybug_pandas.extension_types.dtype module</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../../../ladybug_pandas.extension_types.html#module-ladybug_pandas.extension_types">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ladybug_pandas.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../ladybug_pandas.dataframe.html">ladybug_pandas.dataframe module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../ladybug_pandas.series.html">ladybug_pandas.series module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ladybug_pandas.html#module-ladybug_pandas">Module contents</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ladybug_pandas.html">ladybug_pandas package</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-4">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ladybug_pandas.html">ladybug_pandas package</a></li>
</ul>

        </div>
      </div>
    <div class="body col-md-8 content" role="main">
      
  <h1>Source code for pandas.core.arrays.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;An interface for extending pandas with custom arrays.</span>

<span class="sd">.. warning::</span>

<span class="sd">   This is an experimental API and subject to breaking changes</span>
<span class="sd">   without warning.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="kn">import</span> <span class="n">set_function_name</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="kn">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">AbstractMethodError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="n">Appender</span><span class="p">,</span> <span class="n">Substitution</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="kn">import</span> <span class="n">validate_fillna_kwargs</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="n">is_array_like</span><span class="p">,</span> <span class="n">is_list_like</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="n">ExtensionDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="n">ABCExtensionArray</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">,</span> <span class="n">ABCSeries</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">isna</span>

<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">pandas.core.algorithms</span> <span class="kn">import</span> <span class="n">_factorize_array</span><span class="p">,</span> <span class="n">unique</span>
<span class="kn">from</span> <span class="nn">pandas.core.missing</span> <span class="kn">import</span> <span class="n">backfill_1d</span><span class="p">,</span> <span class="n">pad_1d</span>
<span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">nargsort</span>

<span class="n">_extension_array_shared_docs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">try_cast_to_ea</span><span class="p">(</span><span class="n">cls_or_instance</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call to `_from_sequence` that returns the object unchanged on Exception.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls_or_instance : ExtensionArray subclass or instance</span>
<span class="sd">    obj : arraylike</span>
<span class="sd">        Values to pass to cls._from_sequence</span>
<span class="sd">    dtype : ExtensionDtype, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ExtensionArray or obj</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cls_or_instance</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># We can&#39;t predict what downstream EA constructors may raise</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">ExtensionArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for custom 1-D array types.</span>

<span class="sd">    pandas will recognize instances of this class as proper arrays</span>
<span class="sd">    with a custom type and will not attempt to coerce them to objects. They</span>
<span class="sd">    may be stored directly inside a :class:`DataFrame` or :class:`Series`.</span>

<span class="sd">    .. versionadded:: 0.23.0</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype</span>
<span class="sd">    nbytes</span>
<span class="sd">    ndim</span>
<span class="sd">    shape</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    argsort</span>
<span class="sd">    astype</span>
<span class="sd">    copy</span>
<span class="sd">    dropna</span>
<span class="sd">    factorize</span>
<span class="sd">    fillna</span>
<span class="sd">    isna</span>
<span class="sd">    ravel</span>
<span class="sd">    repeat</span>
<span class="sd">    searchsorted</span>
<span class="sd">    shift</span>
<span class="sd">    take</span>
<span class="sd">    unique</span>
<span class="sd">    view</span>
<span class="sd">    _concat_same_type</span>
<span class="sd">    _formatter</span>
<span class="sd">    _from_factorized</span>
<span class="sd">    _from_sequence</span>
<span class="sd">    _from_sequence_of_strings</span>
<span class="sd">    _ndarray_values</span>
<span class="sd">    _reduce</span>
<span class="sd">    _values_for_argsort</span>
<span class="sd">    _values_for_factorize</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The interface includes the following abstract methods that must be</span>
<span class="sd">    implemented by subclasses:</span>

<span class="sd">    * _from_sequence</span>
<span class="sd">    * _from_factorized</span>
<span class="sd">    * __getitem__</span>
<span class="sd">    * __len__</span>
<span class="sd">    * dtype</span>
<span class="sd">    * nbytes</span>
<span class="sd">    * isna</span>
<span class="sd">    * take</span>
<span class="sd">    * copy</span>
<span class="sd">    * _concat_same_type</span>

<span class="sd">    A default repr displaying the type, (truncated) data, length,</span>
<span class="sd">    and dtype is provided. It can be customized or replaced by</span>
<span class="sd">    by overriding:</span>

<span class="sd">    * __repr__ : A default repr for the ExtensionArray.</span>
<span class="sd">    * _formatter : Print scalars inside a Series or DataFrame.</span>

<span class="sd">    Some methods require casting the ExtensionArray to an ndarray of Python</span>
<span class="sd">    objects with ``self.astype(object)``, which may be expensive. When</span>
<span class="sd">    performance is a concern, we highly recommend overriding the following</span>
<span class="sd">    methods:</span>

<span class="sd">    * fillna</span>
<span class="sd">    * dropna</span>
<span class="sd">    * unique</span>
<span class="sd">    * factorize / _values_for_factorize</span>
<span class="sd">    * argsort / _values_for_argsort</span>
<span class="sd">    * searchsorted</span>

<span class="sd">    The remaining methods implemented on this class should be performant,</span>
<span class="sd">    as they only compose abstract methods. Still, a more efficient</span>
<span class="sd">    implementation may be available, and these methods can be overridden.</span>

<span class="sd">    One can implement methods to handle array reductions.</span>

<span class="sd">    * _reduce</span>

<span class="sd">    One can implement methods to handle parsing from strings that will be used</span>
<span class="sd">    in methods such as ``pandas.io.parsers.read_csv``.</span>

<span class="sd">    * _from_sequence_of_strings</span>

<span class="sd">    This class does not inherit from &#39;abc.ABCMeta&#39; for performance reasons.</span>
<span class="sd">    Methods and properties required by the interface raise</span>
<span class="sd">    ``pandas.errors.AbstractMethodError`` and no ``register`` method is</span>
<span class="sd">    provided for registering virtual subclasses.</span>

<span class="sd">    ExtensionArrays are limited to 1 dimension.</span>

<span class="sd">    They may be backed by none, one, or many NumPy arrays. For example,</span>
<span class="sd">    ``pandas.Categorical`` is an extension array backed by two arrays,</span>
<span class="sd">    one for codes and one for categories. An array of IPv6 address may</span>
<span class="sd">    be backed by a NumPy structured array with two fields, one for the</span>
<span class="sd">    lower 64 bits and one for the upper 64 bits. Or they may be backed</span>
<span class="sd">    by some other storage type, like Python lists. Pandas makes no</span>
<span class="sd">    assumptions on how the data are stored, just that it can be converted</span>
<span class="sd">    to a NumPy array.</span>
<span class="sd">    The ExtensionArray interface does not impose any rules on how this data</span>
<span class="sd">    is stored. However, currently, the backing data cannot be stored in</span>
<span class="sd">    attributes called ``.values`` or ``._values`` to ensure full compatibility</span>
<span class="sd">    with pandas internals. But other names as ``.data``, ``._data``,</span>
<span class="sd">    ``._items``, ... can be freely used.</span>

<span class="sd">    If implementing NumPy&#39;s ``__array_ufunc__`` interface, pandas expects</span>
<span class="sd">    that</span>

<span class="sd">    1. You defer by returning ``NotImplemented`` when any Series are present</span>
<span class="sd">       in `inputs`. Pandas will extract the arrays and call the ufunc again.</span>
<span class="sd">    2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.</span>
<span class="sd">       Pandas inspect this to determine whether the ufunc is valid for the</span>
<span class="sd">       types present.</span>

<span class="sd">    See :ref:`extending.extension.ufunc` for more.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># &#39;_typ&#39; is for pandas.core.dtypes.generic.ABCExtensionArray.</span>
    <span class="c1"># Don&#39;t override this.</span>
    <span class="n">_typ</span> <span class="o">=</span> <span class="s2">&quot;extension&quot;</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_sequence</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ExtensionArray from a sequence of scalars.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars : Sequence</span>
<span class="sd">            Each element will be an instance of the scalar type for this</span>
<span class="sd">            array, ``cls.dtype.type``.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            Construct for this particular dtype. This should be a Dtype</span>
<span class="sd">            compatible with the ExtensionArray.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            If True, copy the underlying data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_sequence_of_strings</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">strings</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new ExtensionArray from a sequence of strings.</span>

<span class="sd">        .. versionadded:: 0.24.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strings : Sequence</span>
<span class="sd">            Each element will be an instance of the scalar type for this</span>
<span class="sd">            array, ``cls.dtype.type``.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            Construct for this particular dtype. This should be a Dtype</span>
<span class="sd">            compatible with the ExtensionArray.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            If True, copy the underlying data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_factorized</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">original</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct an ExtensionArray after factorization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">            An integer ndarray with the factorized values.</span>
<span class="sd">        original : ExtensionArray</span>
<span class="sd">            The original ExtensionArray that factorize was called on.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        factorize</span>
<span class="sd">        ExtensionArray.factorize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Must be a Sequence</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># type (Any) -&gt; Any</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a subset of self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : int, slice, or ndarray</span>
<span class="sd">            * int: The position in &#39;self&#39; to get.</span>

<span class="sd">            * slice: A slice object, where &#39;start&#39;, &#39;stop&#39;, and &#39;step&#39; are</span>
<span class="sd">              integers or None</span>

<span class="sd">            * ndarray: A 1-d boolean NumPy ndarray the same length as &#39;self&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        item : scalar or ExtensionArray</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For scalar ``item``, return a scalar value suitable for the array&#39;s</span>
<span class="sd">        type. This should be an instance of ``self.dtype.type``.</span>

<span class="sd">        For slice ``key``, return an instance of ``ExtensionArray``, even</span>
<span class="sd">        if the slice is length 0 or 1.</span>

<span class="sd">        For a boolean mask, return an instance of ``ExtensionArray``, filtered</span>
<span class="sd">        to the values where ``item`` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set one or more values inplace.</span>

<span class="sd">        This method is not required to satisfy the pandas extension array</span>
<span class="sd">        interface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int, ndarray, or slice</span>
<span class="sd">            When called from, e.g. ``Series.__setitem__``, ``key`` will be</span>
<span class="sd">            one of</span>

<span class="sd">            * scalar int</span>
<span class="sd">            * ndarray of integers.</span>
<span class="sd">            * boolean ndarray</span>
<span class="sd">            * slice object</span>

<span class="sd">        value : ExtensionDtype.type, Sequence[ExtensionDtype.type], or object</span>
<span class="sd">            value or values to be set of ``key``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some notes to the ExtensionArray implementor who may have ended up</span>
        <span class="c1"># here. While this method is not required for the interface, if you</span>
        <span class="c1"># *do* choose to implement __setitem__, then some semantics should be</span>
        <span class="c1"># observed:</span>
        <span class="c1">#</span>
        <span class="c1"># * Setting multiple values : ExtensionArrays should support setting</span>
        <span class="c1">#   multiple values at once, &#39;key&#39; will be a sequence of integers and</span>
        <span class="c1">#  &#39;value&#39; will be a same-length sequence.</span>
        <span class="c1">#</span>
        <span class="c1"># * Broadcasting : For a sequence &#39;key&#39; and a scalar &#39;value&#39;,</span>
        <span class="c1">#   each position in &#39;key&#39; should be set to &#39;value&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># * Coercion : Most users will expect basic coercion to work. For</span>
        <span class="c1">#   example, a string like &#39;2018-01-01&#39; is coerced to a datetime</span>
        <span class="c1">#   when setting on a datetime64ns array. In general, if the</span>
        <span class="c1">#   __init__ method coerces that value, then so should __setitem__</span>
        <span class="c1"># Note, also, that Series/DataFrame.where internally use __setitem__</span>
        <span class="c1"># on a copy of the data.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not implement __setitem__.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Length of this array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        length : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over elements of the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This needs to be implemented so that pandas recognizes extension</span>
        <span class="c1"># arrays as list-like. The default implementation makes successive</span>
        <span class="c1"># calls to ``__getitem__``, which may be slower than necessary.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to a NumPy ndarray.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        This is similar to :meth:`numpy.asarray`, but may provide additional control</span>
<span class="sd">        over how the conversion is done.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or numpy.dtype, optional</span>
<span class="sd">            The dtype to pass to :meth:`numpy.asarray`.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to ensure that the returned value is a not a view on</span>
<span class="sd">            another array. Note that ``copy=False`` does not *ensure* that</span>
<span class="sd">            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that</span>
<span class="sd">            a copy is made, even if not strictly necessary.</span>
<span class="sd">        na_value : Any, optional</span>
<span class="sd">            The value to use for missing values. The default value depends</span>
<span class="sd">            on `dtype` and the type of the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">or</span> <span class="n">na_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">na_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span> <span class="o">=</span> <span class="n">na_value</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Required attributes</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExtensionDtype</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An instance of &#39;ExtensionDtype&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of the array dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of elements in the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extension Arrays are only allowed to be 1-dimensional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of bytes needed to store this object in memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is expensive to compute, return an approximate lower bound</span>
        <span class="c1"># on the number of bytes needed.</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Additional Methods</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to a NumPy array with &#39;dtype&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or dtype</span>
<span class="sd">            Typecode or data-type to which the array is cast.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to copy the data, even if not necessary. If False,</span>
<span class="sd">            a copy is made only if the old dtype does not match the</span>
<span class="sd">            new dtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : ndarray</span>
<span class="sd">            NumPy ndarray with &#39;dtype&#39; for its dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 1-D array indicating if each value is missing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        na_values : Union[np.ndarray, ExtensionArray]</span>
<span class="sd">            In most cases, this should return a NumPy ndarray. For</span>
<span class="sd">            exceptional cases like ``SparseArray``, where returning</span>
<span class="sd">            an ndarray would be expensive, an ExtensionArray may be</span>
<span class="sd">            returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If returning an ExtensionArray, then</span>

<span class="sd">        * ``na_values._is_boolean`` should be True</span>
<span class="sd">        * `na_values` should implement :func:`ExtensionArray._reduce`</span>
<span class="sd">        * ``na_values.any`` and ``na_values.all`` should be implemented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_values_for_argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return values for sorting.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            The transformed values should maintain the ordering between values</span>
<span class="sd">            within the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ExtensionArray.argsort</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: this is used in `ExtensionArray.argsort`.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices that would sort this array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            Whether the indices should result in an ascending</span>
<span class="sd">            or descending sort.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">            Sorting algorithm.</span>
<span class="sd">        *args, **kwargs:</span>
<span class="sd">            passed through to :func:`numpy.argsort`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Array of indices that sort ``self``. If NaN values are contained,</span>
<span class="sd">            NaN values are placed at the end.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.argsort : Sorting implementation used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Implementor note: You have two places to override the behavior of</span>
        <span class="c1"># argsort.</span>
        <span class="c1"># 1. _values_for_argsort : construct the values passed to np.argsort</span>
        <span class="c1"># 2. argsort : total control over sorting.</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_argsort_with_ascending</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, array-like</span>
<span class="sd">            If a scalar value is passed it is used to fill all missing values.</span>
<span class="sd">            Alternatively, an array-like &#39;value&#39; can be given. It&#39;s expected</span>
<span class="sd">            that the array-like have the same length as &#39;self&#39;.</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series</span>
<span class="sd">            pad / ffill: propagate last valid observation forward to next valid</span>
<span class="sd">            backfill / bfill: use NEXT valid observation to fill gap.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="sd">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="sd">            be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">            With NA/NaN filled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">validate_fillna_kwargs</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_array_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Length of &#39;value&#39; does not match. Got (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">pad_1d</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pad&quot;</span> <span class="k">else</span> <span class="n">backfill_1d</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fill with value</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_values</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ExtensionArray without NA values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valid : ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ABCExtensionArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift values by desired number.</span>

<span class="sd">        Newly introduced missing values are filled with</span>
<span class="sd">        ``self.dtype.na_value``.</span>

<span class="sd">        .. versionadded:: 0.24.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int, default 1</span>
<span class="sd">            The number of periods to shift. Negative values are allowed</span>
<span class="sd">            for shifting backwards.</span>

<span class="sd">        fill_value : object, optional</span>
<span class="sd">            The scalar value to use for newly introduced missing values.</span>
<span class="sd">            The default is ``self.dtype.na_value``.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">            Shifted.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``self`` is empty or ``periods`` is 0, a copy of ``self`` is</span>
<span class="sd">        returned.</span>

<span class="sd">        If ``periods &gt; len(self)``, then an array of size</span>
<span class="sd">        len(self) is returned, with all values filled with</span>
<span class="sd">        ``self.dtype.na_value``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: this implementation assumes that `self.dtype.na_value` can be</span>
        <span class="c1"># stored in an instance of your ExtensionArray with `self.dtype`.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">na_value</span>

        <span class="n">empty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span>
            <span class="p">[</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span> <span class="p">:]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">empty</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concat_same_type</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the ExtensionArray of unique values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        uniques : ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find indices where elements should be inserted to maintain order.</span>

<span class="sd">        .. versionadded:: 0.24.0</span>

<span class="sd">        Find the indices into a sorted array `self` (a) such that, if the</span>
<span class="sd">        corresponding elements in `value` were inserted before the indices,</span>
<span class="sd">        the order of `self` would be preserved.</span>

<span class="sd">        Assuming that `self` is sorted:</span>

<span class="sd">        ======  ================================</span>
<span class="sd">        `side`  returned index `i` satisfies</span>
<span class="sd">        ======  ================================</span>
<span class="sd">        left    ``self[i-1] &lt; value &lt;= self[i]``</span>
<span class="sd">        right   ``self[i-1] &lt;= value &lt; self[i]``</span>
<span class="sd">        ======  ================================</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : array_like</span>
<span class="sd">            Values to insert into `self`.</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">            If &#39;left&#39;, the index of the first suitable location found is given.</span>
<span class="sd">            If &#39;right&#39;, return the last such index.  If there is no suitable</span>
<span class="sd">            index, return either 0 or N (where N is the length of `self`).</span>
<span class="sd">        sorter : 1-D array_like, optional</span>
<span class="sd">            Optional array of integer indices that sort array a into ascending</span>
<span class="sd">            order. They are typically the result of argsort.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of ints</span>
<span class="sd">            Array of insertion points with the same shape as `value`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.searchsorted : Similar method from NumPy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: the base tests provided by pandas only test the basics.</span>
        <span class="c1"># We do not test</span>
        <span class="c1"># 1. Values outside the range of the `data_for_sorting` fixture</span>
        <span class="c1"># 2. Values between the values in the `data_for_sorting` fixture</span>
        <span class="c1"># 3. Missing values.</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_values_for_factorize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array and missing value suitable for factorization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : ndarray</span>

<span class="sd">            An array suitable for factorization. This should maintain order</span>
<span class="sd">            and be a supported dtype (Float64, Int64, UInt64, String, Object).</span>
<span class="sd">            By default, the extension array is cast to object dtype.</span>
<span class="sd">        na_value : object</span>
<span class="sd">            The value in `values` to consider missing. This will be treated</span>
<span class="sd">            as NA in the factorization routines, so it will be coded as</span>
<span class="sd">            `na_sentinal` and not included in `uniques`. By default,</span>
<span class="sd">            ``np.nan`` is used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The values returned by this method are also used in</span>
<span class="sd">        :func:`pandas.util.hash_pandas_object`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="nf">factorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na_sentinel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCExtensionArray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode the extension array as an enumerated type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na_sentinel : int, default -1</span>
<span class="sd">            Value to use in the `codes` array to indicate missing values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        codes : ndarray</span>
<span class="sd">            An integer NumPy array that&#39;s an indexer into the original</span>
<span class="sd">            ExtensionArray.</span>
<span class="sd">        uniques : ExtensionArray</span>
<span class="sd">            An ExtensionArray containing the unique values of `self`.</span>

<span class="sd">            .. note::</span>

<span class="sd">               uniques will *not* contain an entry for the NA value of</span>
<span class="sd">               the ExtensionArray if there are any missing values present</span>
<span class="sd">               in `self`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        factorize : Top-level factorize method that dispatches here.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        :meth:`pandas.factorize` offers a `sort` keyword as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Implementer note: There are two ways to override the behavior of</span>
        <span class="c1"># pandas.factorize</span>
        <span class="c1"># 1. _values_for_factorize and _from_factorize.</span>
        <span class="c1">#    Specify the values passed to pandas&#39; internal factorization</span>
        <span class="c1">#    routines, and how to convert from those values back to the</span>
        <span class="c1">#    original ExtensionArray.</span>
        <span class="c1"># 2. ExtensionArray.factorize.</span>
        <span class="c1">#    Complete control over factorization.</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">na_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values_for_factorize</span><span class="p">()</span>

        <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span> <span class="o">=</span> <span class="n">_factorize_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="p">,</span> <span class="n">na_sentinel</span><span class="o">=</span><span class="n">na_sentinel</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">na_value</span>
        <span class="p">)</span>

        <span class="n">uniques</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_factorized</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">codes</span><span class="p">,</span> <span class="n">uniques</span>

    <span class="n">_extension_array_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;repeat&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Repeat elements of a </span><span class="si">%(klass)s</span><span class="s2">.</span>

<span class="s2">        Returns a new </span><span class="si">%(klass)s</span><span class="s2"> where each element of the current </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">        is repeated consecutively a given number of times.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        repeats : int or array of ints</span>
<span class="s2">            The number of repetitions for each element. This should be a</span>
<span class="s2">            non-negative integer. Repeating 0 times will return an empty</span>
<span class="s2">            </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">        axis : None</span>
<span class="s2">            Must be ``None``. Has no effect but is accepted for compatibility</span>
<span class="s2">            with numpy.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        repeated_array : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">            Newly created </span><span class="si">%(klass)s</span><span class="s2"> with repeated elements.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        Series.repeat : Equivalent function for Series.</span>
<span class="s2">        Index.repeat : Equivalent function for Index.</span>
<span class="s2">        numpy.repeat : Similar method for :class:`numpy.ndarray`.</span>
<span class="s2">        ExtensionArray.take : Take arbitrary positions.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; cat = pd.Categorical([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="s2">        &gt;&gt;&gt; cat</span>
<span class="s2">        [a, b, c]</span>
<span class="s2">        Categories (3, object): [a, b, c]</span>
<span class="s2">        &gt;&gt;&gt; cat.repeat(2)</span>
<span class="s2">        [a, a, b, b, c, c]</span>
<span class="s2">        Categories (3, object): [a, b, c]</span>
<span class="s2">        &gt;&gt;&gt; cat.repeat([1, 2, 3])</span>
<span class="s2">        [a, b, b, c, c, c]</span>
<span class="s2">        Categories (3, object): [a, b, c]</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;ExtensionArray&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_extension_array_shared_docs</span><span class="p">[</span><span class="s2">&quot;repeat&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_repeat</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Indexing methods</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">allow_fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ABCExtensionArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take elements from an array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : sequence of int</span>
<span class="sd">            Indices to be taken.</span>
<span class="sd">        allow_fill : bool, default False</span>
<span class="sd">            How to handle negative values in `indices`.</span>

<span class="sd">            * False: negative values in `indices` indicate positional indices</span>
<span class="sd">              from the right (the default). This is similar to</span>
<span class="sd">              :func:`numpy.take`.</span>

<span class="sd">            * True: negative values in `indices` indicate</span>
<span class="sd">              missing values. These values are set to `fill_value`. Any other</span>
<span class="sd">              other negative values raise a ``ValueError``.</span>

<span class="sd">        fill_value : any, optional</span>
<span class="sd">            Fill value to use for NA-indices when `allow_fill` is True.</span>
<span class="sd">            This may be ``None``, in which case the default NA value for</span>
<span class="sd">            the type, ``self.dtype.na_value``, is used.</span>

<span class="sd">            For many ExtensionArrays, there will be two representations of</span>
<span class="sd">            `fill_value`: a user-facing &quot;boxed&quot; scalar, and a low-level</span>
<span class="sd">            physical NA value. `fill_value` should be the user-facing version,</span>
<span class="sd">            and the implementation should handle translating that to the</span>
<span class="sd">            physical version for processing the take if necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            When the indices are out of bounds for the array.</span>
<span class="sd">        ValueError</span>
<span class="sd">            When `indices` contains negative values other than ``-1``</span>
<span class="sd">            and `allow_fill` is True.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.take</span>
<span class="sd">        api.extensions.take</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ExtensionArray.take is called by ``Series.__getitem__``, ``.loc``,</span>
<span class="sd">        ``iloc``, when `indices` is a sequence of values. Additionally,</span>
<span class="sd">        it&#39;s called by :meth:`Series.reindex`, or any other method</span>
<span class="sd">        that causes realignment, with a `fill_value`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here&#39;s an example implementation, which relies on casting the</span>
<span class="sd">        extension array to object dtype. This uses the helper method</span>
<span class="sd">        :func:`pandas.api.extensions.take`.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           def take(self, indices, allow_fill=False, fill_value=None):</span>
<span class="sd">               from pandas.core.algorithms import take</span>

<span class="sd">               # If the ExtensionArray is backed by an ndarray, then</span>
<span class="sd">               # just pass that here instead of coercing to object.</span>
<span class="sd">               data = self.astype(object)</span>

<span class="sd">               if allow_fill and fill_value is None:</span>
<span class="sd">                   fill_value = self.dtype.na_value</span>

<span class="sd">               # fill value should always be translated from the scalar</span>
<span class="sd">               # type for the array, to the physical storage type for</span>
<span class="sd">               # the data, before passing to take.</span>

<span class="sd">               result = take(data, indices, fill_value=fill_value,</span>
<span class="sd">                             allow_fill=allow_fill)</span>
<span class="sd">               return self._from_sequence(result, dtype=self.dtype)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Implementer note: The `fill_value` parameter should be a user-facing</span>
        <span class="c1"># value, an instance of self.dtype.type. When passed `fill_value=None`,</span>
        <span class="c1"># the default of `self.dtype.na_value` should be used.</span>
        <span class="c1"># This may differ from the physical storage type your ExtensionArray</span>
        <span class="c1"># uses. In this case, your implementation is responsible for casting</span>
        <span class="c1"># the user-facing type to the storage type, before using</span>
        <span class="c1"># pandas.api.extensions.take</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ABCExtensionArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">ABCExtensionArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a view on the array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str, np.dtype, or ExtensionDtype, optional</span>
<span class="sd">            Default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">            A view of the :class:`ExtensionArray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NB:</span>
        <span class="c1"># - This must return a *new* object referencing the same data, not self.</span>
        <span class="c1"># - The only case that *must* be implemented is with dtype=None,</span>
        <span class="c1">#   giving a view with the same dtype as self.</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:]</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Printing</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="kn">import</span> <span class="n">format_object_summary</span>

        <span class="c1"># the short repr has no trailing newline, while the truncated</span>
        <span class="c1"># repr does. So we include a newline in our template, and strip</span>
        <span class="c1"># any trailing newlines from format_object_summary</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">format_object_summary</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">(),</span> <span class="n">indent_for_name</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;, </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}{</span><span class="n">data</span><span class="si">}</span><span class="se">\n</span><span class="s2">Length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, dtype: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Formatting function for scalar values.</span>

<span class="sd">        This is used in the default &#39;__repr__&#39;. The returned formatting</span>
<span class="sd">        function receives instances of your scalar type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        boxed : bool, default False</span>
<span class="sd">            An indicated for whether or not your array is being printed</span>
<span class="sd">            within a Series, DataFrame, or Index (True), or just by</span>
<span class="sd">            itself (False). This may be useful if you want scalar values</span>
<span class="sd">            to appear differently within a Series versus on its own (e.g.</span>
<span class="sd">            quoted or not).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable[[Any], str]</span>
<span class="sd">            A callable that gets instances of the scalar type and</span>
<span class="sd">            returns a string. By default, :func:`repr` is used</span>
<span class="sd">            when ``boxed=False`` and :func:`str` is used when</span>
<span class="sd">            ``boxed=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">boxed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span>
        <span class="k">return</span> <span class="nb">repr</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Reshaping</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ABCExtensionArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a flattened view on this array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {None, &#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, default &#39;C&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Because ExtensionArrays are 1D-only, this is a no-op.</span>
<span class="sd">        - The &quot;order&quot; argument is ignored, is for compatibility with NumPy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_concat_same_type</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">to_concat</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ABCExtensionArray</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ABCExtensionArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate multiple array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_concat : sequence of this type</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="c1"># The _can_hold_na attribute is set to True so that pandas internals</span>
    <span class="c1"># will use the ExtensionDtype.na_value as the NA value in operations</span>
    <span class="c1"># such as take(), reindex(), shift(), etc.  In addition, those results</span>
    <span class="c1"># will then be of the ExtensionArray subclass rather than an array</span>
    <span class="c1"># of objects</span>
    <span class="n">_can_hold_na</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ndarray_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal pandas method for lossy conversion to a NumPy ndarray.</span>

<span class="sd">        This method is not part of the pandas interface.</span>

<span class="sd">        The expectation is that this is cheap to compute, and is primarily</span>
<span class="sd">        used for interacting with our indexers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array : ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a scalar result of performing the reduction operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the function, supported values are:</span>
<span class="sd">            { any, all, min, max, sum, mean, median, prod,</span>
<span class="sd">            std, var, sem, kurt, skew }.</span>
<span class="sd">        skipna : bool, default True</span>
<span class="sd">            If True, skip NaN values.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to the reduction function.</span>
<span class="sd">            Currently, `ddof` is the only supported kwarg.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError : subclass does not define reductions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot perform </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ExtensionOpsMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class for linking the operators to their dunder names.</span>

<span class="sd">    .. note::</span>

<span class="sd">       You may want to set ``__array_priority__`` if you want your</span>
<span class="sd">       implementation to be called when involved in binary operations</span>
<span class="sd">       with NumPy arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_arithmetic_ops</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__add__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__radd__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">radd</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__sub__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rsub__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rsub</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__mul__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rmul__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rmul</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__pow__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rpow__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rpow</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__mod__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rmod__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rmod</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__floordiv__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rfloordiv__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rfloordiv</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__truediv__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rtruediv__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rtruediv</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__divmod__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="nb">divmod</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rdivmod__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_arithmetic_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rdivmod</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_comparison_ops</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__eq__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__ne__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__lt__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__gt__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__le__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__ge__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_logical_ops</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__and__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_logical_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rand__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_logical_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rand_</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__or__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_logical_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__ror__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_logical_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">ror_</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__xor__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_logical_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__rxor__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_logical_method</span><span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">rxor</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ExtensionScalarOpsMixin</span><span class="p">(</span><span class="n">ExtensionOpsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin for defining  ops on an ExtensionArray.</span>

<span class="sd">    It is assumed that the underlying scalar objects have the operators</span>
<span class="sd">    already defined.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If you have defined a subclass MyExtensionArray(ExtensionArray), then</span>
<span class="sd">    use MyExtensionArray(ExtensionArray, ExtensionScalarOpsMixin) to</span>
<span class="sd">    get the arithmetic operators.  After the definition of MyExtensionArray,</span>
<span class="sd">    insert the lines</span>

<span class="sd">    MyExtensionArray._add_arithmetic_ops()</span>
<span class="sd">    MyExtensionArray._add_comparison_ops()</span>

<span class="sd">    to link the operators to your class.</span>

<span class="sd">    .. note::</span>

<span class="sd">       You may want to set ``__array_priority__`` if you want your</span>
<span class="sd">       implementation to be called when involved in binary operations</span>
<span class="sd">       with NumPy arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">coerce_to_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class method that returns a method that will correspond to an</span>
<span class="sd">        operator for an ExtensionArray subclass, by dispatching to the</span>
<span class="sd">        relevant operator defined on the individual elements of the</span>
<span class="sd">        ExtensionArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : function</span>
<span class="sd">            An operator that takes arguments op(a, b)</span>
<span class="sd">        coerce_to_dtype : bool, default True</span>
<span class="sd">            boolean indicating whether to attempt to convert</span>
<span class="sd">            the result to the underlying ExtensionArray dtype.</span>
<span class="sd">            If it&#39;s not possible to create a new ExtensionArray with the</span>
<span class="sd">            values, an ndarray is returned instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable[[Any, Any], Union[ndarray, ExtensionArray]]</span>
<span class="sd">            A method that can be bound to a class. When used, the method</span>
<span class="sd">            receives the two arguments, one of which is the instance of</span>
<span class="sd">            this class, and should return an ExtensionArray or an ndarray.</span>

<span class="sd">            Returning an ndarray may be necessary when the result of the</span>
<span class="sd">            `op` cannot be stored in the ExtensionArray. The dtype of the</span>
<span class="sd">            ndarray uses NumPy&#39;s normal inference rules.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Given an ExtensionArray subclass called MyExtensionArray, use</span>

<span class="sd">        &gt;&gt;&gt; __add__ = cls._create_method(operator.add)</span>

<span class="sd">        in the class definition of MyExtensionArray to create the operator</span>
<span class="sd">        for addition, that will be based on the operator implementation</span>
<span class="sd">        of the underlying elements of the ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">convert_values</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                    <span class="n">ovalues</span> <span class="o">=</span> <span class="n">param</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Assume its an object</span>
                    <span class="n">ovalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ovalues</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
                <span class="c1"># rely on pandas to unbox and dispatch to us</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="n">lvalues</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">rvalues</span> <span class="o">=</span> <span class="n">convert_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="c1"># If the operator is not defined for the underlying objects,</span>
            <span class="c1"># a TypeError should be raised</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">)]</span>

            <span class="k">def</span> <span class="nf">_maybe_convert</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">coerce_to_dtype</span><span class="p">:</span>
                    <span class="c1"># https://github.com/pandas-dev/pandas/issues/22850</span>
                    <span class="c1"># We catch all regular exceptions here, and fall back</span>
                    <span class="c1"># to an ndarray.</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">try_cast_to_ea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                        <span class="c1"># exception raised in _from_sequence; ensure we have ndarray</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;divmod&quot;</span><span class="p">,</span> <span class="s2">&quot;rdivmod&quot;</span><span class="p">}:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_maybe_convert</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_maybe_convert</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_maybe_convert</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="n">op_name</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">_binop</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_arithmetic_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_method</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_comparison_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_method</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">coerce_to_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020, Ladybug Tools.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>